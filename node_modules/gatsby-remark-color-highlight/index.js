"use strict";

var visit = require("unist-util-visit");

var jsdom = require("jsdom");

var Color = require("color");

var JSDOM = jsdom.JSDOM;

module.exports = function (_ref, _ref2) {
  var markdownAST = _ref.markdownAST;
  var _ref2$wrapperElement = _ref2.wrapperElement,
      wrapperElement = _ref2$wrapperElement === void 0 ? "code" : _ref2$wrapperElement,
      _ref2$className = _ref2.className,
      className = _ref2$className === void 0 ? "color-highlight" : _ref2$className,
      _ref2$searchNodeTypes = _ref2.searchNodeTypes,
      searchNodeTypes = _ref2$searchNodeTypes === void 0 ? ["text", "paragraph", "inlineCode", "html"] : _ref2$searchNodeTypes;

  // can't allow empty class, because `traverseHtml` will then become infinite due
  // to newly inserted html nodes, which will have replacable content again and again
  if (!className) {
    throw Error("A (preferrably) unique CSS class must be set for `gatsby-remark-color-highlight`.");
  } // thanks to https://stackoverflow.com/a/1636354/744230


  var hexCodeRegex = /#(?:[0-9a-fA-F]{3}){1,2}/gim;
  var checkForReplacableHtmlHexCodeRegex = /<[\w]+[^>]*>.*?(?:#(?:[0-9a-fA-F]{3}){1,2})<\/[\w]+>/gim; // test must be either string or `unist-util-is` compatible function
  //  https://github.com/syntax-tree/unist-util-is

  var test = function test(node, n) {
    if (searchNodeTypes.indexOf(node.type) > -1) {
      if (node.type === "html") {
        var nodeFragment = JSDOM.fragment(node.value);
        return checkForReplacableHtmlHexCodeRegex.test(nodeFragment.children[0].innerHTML);
      }

      return hexCodeRegex.test(node.value);
    }

    return false;
  };

  var buildNodeHtml = function buildNodeHtml(color) {
    return "<" + wrapperElement + " class=\"" + className + "\" style=\"background-color: " + color + "; color: " + (Color(color).isLight() ? "#000" : "#fff") + "\">" + color + "</" + wrapperElement + ">";
  };

  var buildColorNode = function buildColorNode(color) {
    return {
      type: "html",
      children: [],
      value: buildNodeHtml(color)
    };
  };

  var traverseHtml = function traverseHtml(htmlNode) {
    // thanks to https://stackoverflow.com/a/18622606/744230
    var replaceColorHexOutsideTags = /(#(?:[0-9a-fA-F]{3}){1,2})(?![^<]*>|[^<>]*<\/)/gim;
    var newHtml = htmlNode.innerHTML.replace(replaceColorHexOutsideTags, buildNodeHtml);
    htmlNode.innerHTML = newHtml;
    var htmlChildNodes = htmlNode.childNodes;

    for (var i = 0; i < htmlChildNodes.length; i++) {
      if (!htmlChildNodes[i]) continue;

      if (htmlChildNodes[i].childNodes.length > 0) {
        // this is our current way to prevent an infinite loop and skip newly added html code
        if (htmlChildNodes[i].classList.contains(className)) continue;
        traverseHtml(htmlChildNodes[i]);
      }
    }
  };

  visit(markdownAST, test, function (node, index, parent) {
    var text = node.value;
    var parts = [],
        matches = [];

    if (node.type === "html") {
      // add surrounding `div` because we will then easily access
      // and transform the child node
      var nodeFragment = JSDOM.fragment("<div>" + node.value + "</div>");
      var nodeFragmentElement = nodeFragment.children[0];
      traverseHtml(nodeFragmentElement);
      node.value = nodeFragmentElement.innerHTML;
    } else {
      var _parent$children;

      // for everything else but html nodes
      parts = text.split(hexCodeRegex);
      matches = text.match(hexCodeRegex);
      var replacementChilds = [];

      for (var i = 0; i < parts.length; i++) {
        var nodeCopy = JSON.parse(JSON.stringify(node));
        nodeCopy.value = parts[i];
        delete nodeCopy.position;
        delete nodeCopy.indent;

        if (nodeCopy.value !== "") {
          replacementChilds.push(nodeCopy);
        } // make sure matches[i] exists


        if (i < matches.length) {
          replacementChilds.push(buildColorNode(matches[i]));
        }
      }

      (_parent$children = parent.children).splice.apply(_parent$children, [index, 1].concat(replacementChilds));

      return index + replacementChilds.length - 1;
    }
  });
  return markdownAST;
};